---
alwaysApply: false
---

- 이 문서를 참조했을 시 답변 전, [Architect] 단어 출력

## 시스템 설계 (Futures Remote Microservice)

### 목표/범위
- **목표**: Binance Futures 원클릭 매수/매도 + 현재 포지션 조회
- **스코프**: 단일 사용자 내부용. 필수 입력값만. 기타 기능 제외
- **성공 기준**: p50 < 800ms(서버 왕복), 주문 성공률 ≥ 99.9%, 포지션 최신화 지연 < 2.5s

### 아키텍처 개요
- **프런트**: 정적 SPA(단일 화면) → 백엔드 REST 호출
- **백엔드**: 단일 Web API 서비스
  - 기술 스택: Python 3.11 + FastAPI + Uvicorn
  - 필수 라이브러리: `httpx`(HTTP), `pydantic`(검증), `cachetools`(TTL 캐시), `tenacity`(재시도)
  - `TradeController` (`POST /api/trade`)
  - `PositionsController` (`GET /api/positions`)
  - `OrderService`, `PositionService`
  - `BinanceFuturesClient`(서명/HMAC, 엔드포인트 래핑)
  - `SymbolMetaCache`(exchangeInfo/필터 30초 캐시), `PriceCache`(markPrice 2초 캐시)
  - `LeverageManager`(심볼별 레버리지 설정/캐시)
  - `AuthMiddleware`(단일 토큰), `ErrorHandler`, `Logger`, `Config`

### UI/UX (단일 화면: Futures Remote)
- 상단: `종목(symbol)` 드롭다운, `금액(USDT)` 입력, `레버리지(1–25)` 슬라이더, `사이드(BUY/SELL)` 토글
- 중앙: 대형 버튼 2개 `[매수]` `[매도]` (선택 사이드 강조)
- 하단: `현재 포지션` 테이블(심볼/수량/진입가/레버리지/미실현PnL/마진모드) + 2초 폴링 인디케이터
- 피드백: 성공/실패 토스트. 실패 사유 간결 표기(필터/금액/레버리지/잔고/레이트리밋)

### API 설계
- `POST /api/trade`
  - 요청: `{ symbol, notional, leverage, side }`
  - 응답(성공): `{ orderId, symbol, side, executedQty, avgPrice, status }`
  - 에러: 400(유효성/필터 위반), 402(잔고 부족), 429(레이트리밋), 5xx(외부 장애)
- `GET /api/positions`
  - 응답: `[{ symbol, positionAmt, entryPrice, leverage, unRealizedProfit, marginType }]`

### Binance 연계
- 사용 엔드포인트
  - `GET /api/v1/exchangeInfo`(심볼/필터, 30초 캐시)
  - `GET /api/v1/premiumIndex` 또는 `GET /api/v1/markPrice`(마크프라이스, 2초 캐시)
  - `POST /api/v1/leverage`(심볼별 레버리지, 필요 시에만 호출)
  - `POST /api/v1/order`(MARKET, `reduceOnly=false`)
  - `GET /api/v2/positionRisk`(포지션 조회)
- 환경 전환: `USE_TESTNET=true` 시 테스트넷 URL 사용(기본값 true)

### 수량 계산/유효성
- 입력 검증: `symbol ∈ whitelist`, `notional > 0`, `leverage ∈ [1,25]`, `side ∈ {BUY, SELL}`
- 계산 절차
  1) `markPrice` 조회
  2) `rawQty = notional / markPrice`
  3) `qty = roundDownToStep(rawQty, stepSize)`; `qty ≥ minQty` 확인
  4) `notionalCheck = qty * markPrice ≥ minNotional` 확인
  5) `pricePrecision`, `quantityPrecision` 준수
- 실패 시: 상세 코드/메시지 반환(예: `MIN_NOTIONAL_VIOLATION`)

### 레버리지 설정
- 심볼별 현재 레버리지 캐시 유지(예: 5분)
- 요청 `leverage`가 상이할 때만 `POST /leverage` 호출
- 실패 시 주문 중단 + 사용자 안내

### 오류/재시도 정책
- 캐시성 GET(exchangeInfo/markPrice/positionRisk): 지수 backoff 최대 1회
- 주문 POST: 재시도 없음(네트워크 타임아웃 시 사용자 안내 및 미중복 원칙 고지)
- 레이트리밋(429): 사용자 안내 + 1회 재시도(주문 제외)

### 보안/인증
- 서버 환경변수: `BINANCE_API_KEY`, `BINANCE_API_SECRET`, `AUTH_TOKEN`, `USE_TESTNET`, `ALLOWED_SYMBOLS`, `CORS_ORIGIN`
- 클라이언트→서버: HTTPS + 단일 토큰 헤더
- 서버→Binance: HMAC 서명, 시계 동기화 주기적 점검
- 로그: 요청ID, 결과코드만. 민감정보/키/서명/원시응답 저장 금지

### 성능/신뢰성
- p50 < 800ms 달성 조치: 캐시 활용(30초/2초), 커넥션 재사용, 최소 직렬 호출(레버리지 필요 시에만)
- 장애 대응: 외부 실패 시 사용자 메시지 + 간단 복구 가이드, 테스트넷 분리 운영

### 로깅/관측성
- 액세스 로그: `ts, reqId, route, status, latencyMs`
- 주문 로그: `reqId, symbol, side, qty, status`
- 에러 로그: `reqId, code, message, cause`
- 선택: Slack/Webhook 알림(심각도 기준)

### 배포/런타임
- 단일 프로세스(백엔드 + 정적 프런트), 제한된 `CORS_ORIGIN`
- 기본값 테스트넷, 프로드 전환 시 토글만 변경
- 헬스체크: `/healthz`(프로세스/시계 동기/환경 변수 점검)
- FastAPI 실행 예: `uvicorn app.main:app --host 0.0.0.0 --port 3000`

### 테스트 시나리오
- 정상: BTCUSDT, 50 USDT, 10x, BUY → `FILLED`
- 경계: `minNotional` 바로 아래/위
- 실패: 미허용 심볼, 레버리지 범위 초과, 잔고 부족, 레이트리밋

### 내부 모듈 책임(SRP)
- `TradeController`: 요청 파싱/검증 → 서비스 호출 → 응답 매핑
- `OrderService`: 레버리지 확인, 수량 계산, 필터 검증, 주문 생성
- `PositionsController/PositionService`: 포지션 조회/정규화
- `BinanceFuturesClient`: REST 호출/서명/시계 보정
- `SymbolMetaCache/PriceCache`: TTL 캐시
- `AuthMiddleware`: 토큰 검증
- `ErrorHandler`: 표준 에러 포맷

### 표준 에러 포맷
```json
{ "requestId":"...", "code":"MIN_NOTIONAL_VIOLATION", "message":"Order notional below minimum." }
```

### 작업 규범 준수
- `vRule.mdc` 원칙 적용: 작은 변경 → 검증 → 요약. 불필요 기능/코드 금지. 병렬 탐색/검증 우선.

- 요약
  - 단일 화면 + 두 개의 핵심 API로 구성된 최소 설계
  - 캐시/유효성/레버리지 관리로 오류율 0% 목표
  - 주문 POST 무재시도, 캐시성 GET 1회 재시도로 신뢰성 확보
  - 보안/성능/유지보수 기준 충족, 스코프 크립 차단
